generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  userId            String    @db.Uuid
  type              String    @db.VarChar(255)
  provider          String    @db.VarChar(255)
  providerAccountId String    @db.VarChar(255)
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?   @db.VarChar(255)
  scope             String?   @db.VarChar(255)
  id_token          String?
  session_state     String?   @db.VarChar(255)
  createdAt         DateTime? @default(now()) @db.Timestamptz(6)
  updatedAt         DateTime? @default(now()) @updatedAt @db.Timestamptz(6)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  sessionToken String    @unique @db.VarChar(255)
  userId       String    @db.Uuid
  expires      DateTime  @db.Timestamptz(6)
  createdAt    DateTime? @default(now()) @db.Timestamptz(6)
  updatedAt    DateTime? @default(now()) @updatedAt @db.Timestamptz(6)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([sessionToken])
  @@index([userId])
  @@map("sessions")
}

model User {
  id            String       @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  email         String       @unique @db.VarChar(255)
  name          String?      @db.VarChar(255)
  image         String?
  emailVerified DateTime?    @db.Timestamptz(6)
  createdAt     DateTime?    @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime?    @default(now()) @updatedAt @db.Timestamptz(6)
  accounts      Account[]
  bookings      Booking[]
  eventImages   EventImage[]
  events        Event[]
  sessions      Session[]

  @@index([email])
  @@map("users")
}

model VerificationToken {
  token      String    @id @db.VarChar(255)
  identifier String    @db.VarChar(255)
  expires    DateTime  @db.Timestamptz(6)
  createdAt  DateTime? @default(now()) @db.Timestamptz(6)

  @@map("verification_tokens")
}

model Event {
  id           String        @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  name         String
  description  String
  category     EventCategory
  date         DateTime      @db.Date
  time         DateTime      @db.Time(6)
  location     String
  address      String
  seats        Int
  hostName     String        @map("host_name")
  hostWhatsapp String        @map("host_whatsapp")
  hostId       String        @map("host_id") @db.Uuid
  imageUrl     String?       @map("image_url")
  createdAt    DateTime      @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime      @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  bookings     Booking[]
  eventImages  EventImage[]
  host         User          @relation(fields: [hostId], references: [id], onDelete: Cascade)

  @@index([category], map: "idx_events_category")
  @@index([createdAt], map: "idx_events_created_at")
  @@index([date], map: "idx_events_date")
  @@index([hostId], map: "idx_events_host_id")
  @@index([location], map: "idx_events_location")
  // Compound indexes for common query patterns
  @@index([date, category], map: "idx_events_date_category")
  @@index([category, date], map: "idx_events_category_date")
  @@index([hostId, date], map: "idx_events_host_date")
  // Text search will be handled via raw SQL migration for full-text search
  @@map("events")
}

model Booking {
  id             String        @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  eventId        String        @map("event_id") @db.Uuid
  userId         String        @map("user_id") @db.Uuid
  numberOfPeople Int           @map("number_of_people")
  status         BookingStatus @default(PENDING)
  createdAt      DateTime      @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt      DateTime      @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  event          Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([createdAt], map: "idx_bookings_created_at")
  @@index([eventId], map: "idx_bookings_event_id")
  @@index([status], map: "idx_bookings_status")
  @@index([userId], map: "idx_bookings_user_id")
  // Compound indexes for common query patterns
  @@index([eventId, status], map: "idx_bookings_event_status")
  @@index([userId, createdAt], map: "idx_bookings_user_created")
  @@index([status, createdAt], map: "idx_bookings_status_created")
  @@map("bookings")
}

model EventImage {
  id           String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  eventId      String    @map("event_id") @db.Uuid
  userId       String    @map("user_id") @db.Uuid
  filename     String
  originalName String    @map("original_name")
  mimeType     String    @map("mime_type")
  sizeBytes    Int       @map("size_bytes")
  filePath     String    @map("file_path")
  isPrimary    Boolean?  @default(false) @map("is_primary")
  createdAt    DateTime? @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime? @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  event        Event     @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([eventId], map: "idx_event_images_event_id")
  @@index([isPrimary], map: "idx_event_images_is_primary")
  @@index([userId], map: "idx_event_images_user_id")
  // Compound index for finding primary images by event
  @@index([eventId, isPrimary], map: "idx_event_images_event_primary")
  @@map("event_images")
}

enum EventCategory {
  PET_MEET    @map("Pet Meet")
  GAMES_NIGHT @map("Games Night")
  RECREATION  @map("Recreation")

  @@map("event_category")
}

enum BookingStatus {
  PENDING   @map("pending")
  CONFIRMED @map("confirmed")
  CANCELLED @map("cancelled")

  @@map("booking_status")
}
